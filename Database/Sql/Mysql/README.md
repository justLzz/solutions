## mysql并发处理相关

- 当前读：读取的是记录的最新版本，并且读取之后还要保证其他并发事务不能修改当前记录，对读取的记录加锁
当前读：select…lock in share mode,select…for update
当前读：update,delete,insert

- 快照读：可能读取的并不是当前记录的最新版本，可能是之前的历史版本
快照读：不加锁的非阻塞读，select
不加锁的条件是在当前事务隔离级别是非serializable前提下才成立，在SE下面，由于是串行读，所以此时的快照读也退化成当前读，即select…lock in share mode模式；
之所以出现快照读，是基于提高并发性能的考虑；
快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免的加锁操作，因此开销更低

- 事务隔离级别

1，未提交读(READ UNCOMMITTED)

这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.

2，已提交读(READ COMMITTED)

其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.在这个隔离级别中当前读和快照读的数据是一样的。

3，REPEATABLE READ(可重复读)

可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id> 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.（数据库默认）这个隔离级别中快照读和当前读读出的数据可能不一样，因为快照读读取的是之前的数据而当前读读取的是最新的数据

4，SERIALIZABLE(可串行化)

这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.

- mysql是如何解决幻读

1，串行化
2，mvcc解决的是快照读下的幻读
3，next-key解决的是当前读下的幻读，Next-Key Lock是Gap Lock（间隙锁）和Record Lock（行锁）的结合版，select * from tb where id>100 for update;主键索引 id 会给 id=100 的记录加上 record行锁，索引 id 上会加上 gap 锁，锁住 id(100,+无穷大）这个范围